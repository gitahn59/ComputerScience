# 해시

해싱은 데이터관리기법 중의 하나로 다량의 데이터를 저장하고 검색하는 데 유용하다.    
해시함수는 찾고자 하는 값을 입력하면, 그 값의 위치를 알 수 있는 해시코드를 계산한다.
일반적으로 해시코드가 같은 두 객체가 존재하는 것이 가능하다.      
이는 해시 함수의 정의역보다 치역의 범위가 더 작기 때문에 발생한다.(비둘기집 원리)   

> Java의 hashCode 메서드
> 기본적으로 주소값을 이용해서 32bit정수의 해쉬값을 계산한다.   
> 32bit 환경에서는 충돌이 발생하지 않지만, 
> 64bit환경에서는 치역이 더 작아지므로 충돌이 발생한다.

> Java의 equals와 hash의 관계
> equals를 오버라이드하여 값을 통해 비교를 하여 서로 다른 객체도 같다고 판정한다면,   
> hashcode도 오버라이드하여 같은 해쉬값을 계산하도록 수정해야한다.   
> 같은 객체라면 같은 해쉬값을 가져야하기 때문이다.

## 해시 충돌
서로 다른 객체 A, B에 대하여(A.equals(B)는 false) 인 경우 A.hashCode()와 B.hashCode() 의 값이 서로 다르면   
이 해시 함수는 완전한 해시 함수(perfect hash functions)라고 한다.   

> Boolean, Integer, Long, DOuble과 같은 Number 객체는 값 자체를 해시 값으로 사용하면 완전 해시 함수이다.   
> String이나 POJO는 완전한 해시 함수 제작이 불가능하다.(무한한 정의역)

hashMap은 기본적으로 각 객체의 hashCode() 메서드의 반환값을 사용하므로, int형 해시 값을 사용한다.
32비트 자료형으로는 완전한 해시 함수를 만들 수 없다.    
게다가 2^32 의 메모리를 가지고 있긴에는 낭비이므로 내부적으로 메모리를 절약하기 위해   
정수 범위 N보다 작은 M개의 원소를 저장하는 배열을 사용한다.    
따라서 M으로 모듈러 연산을 취한 값을 버킷 인덱스 값으로 사용한다.
```java
int idx = A.hashCode() % M;
```

해시 함수의 구현 완성도와 관계없이 1/M의 확률로 반드시 해시 충돌이 발생한다.
이를 보완하는 방법으로 대표적으로 2가지 방식을 사용한다.

### Open Addressing
데이터를 삽입하려는 해시 버킷이 이미 사용중이면 다른 해시(다음 버킷 등) 버킷에 해당 데이터를 삽입한다.   

### Seprate Chaining
리스트를 저장하는 배열을 사용하여 중복되는 값을 리스트에 순차적으로 삽입한다. 

Worst Case의 경우 O(M)이 걸린다. Open Addressing을 연속된 공간에 데이터를 저장하기 때문에   
Separate Chaining에 비하여 캐시 효율이 높다. 데이터 개수가 적다면 더 성능이 좋다.   
하지만 배열의 크기가 커지면 적중률이 낮아진다.

Java HashMap은 Separate Chaining을 사용한다.   
혼동하지 않아야 하는 점은 HashMap 을 사용할 때 하나의 key 값에 하나의 value만 저장된다는 것이다.   
단, 내부적으로 key값을 저장하는 과정에서 모듈로 연산에 의해 발생하는 충돌에 대한 해결책으로 Separate Chaining을    
사용하는 것일 뿐 이를 통해 hashMap이 복수 개의 value를 저장하는 기능을 제공하는 것이 아니다.      
복수개를 저장하려면 value에 collections 를 저장하면 된다.