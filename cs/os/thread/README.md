# Thread
프로세스는 PCB를 생성해야하므로 무겁다(Address space, OS resources, Hardware state)   
즉 프로세스를 생성하는 과정 다 초기화 시켜주어야 하므로 cost가 많이 발생한다.
또한 프로세스간에 커뮤니케이션하는 과정도 비용이 많이 듬(pipe, shared memory)
OS 스케쥴링도 관리할 대상이 증가함

1. 두 프로세스가 협업을 한다면 일반적으로 같은 코드를 사용함
2. 리소스 역시 같이 사용함
3. 단 하드웨어 state만 다름

따라서 이러한 실행 state(PC, SP, registers 등)를 분리해서 사용 -> 쓰레드 / 경량 프로세스   
프로세스는 하나이지만 그 안에서 동작하는 쓰레드는 여러 개   
PCB에는 Process용 정보, TCB(Thread 용 아이템)를 별도로 생성

1. PC / register는 쓰레드 각각 가지고 잇음
2. 코드나 데이터 영역은 공유해서 사용

## 정의
어떤 프로그램에서 실행되고 있는 명령의 흐름
1. 쓰레드들은 프로세스의 코드 영역을 공유 / data 공유(전역 변수)
2. 공유 영역에 의해 다른 쓰레드에서 접근해도 그 변경사항이 유지 됨
3. open file 같은 리소스 공유

## 멀티쓰레딩
1. 병행성을 만드는 비용이 쌈(시간, memory)
2. throughput 증가 
3. 응답성 증가(새로운 쓰레드를 만들기 쉽기 때문)
4. 자원 공유 증가

## 프로세스와 쓰레드의 비교
1. 쓰레드는 single process 내에서 동작
2. process는 multi thread를 가질 수 있음
3. data를 공유하는 비용이 저렴
4. Thread 역시 스케쥴링의 단위임(멀티 코어에 유리)
5. process는 thread의 컨테이너라고 볼 수 있음

비슷한 점
> 각자 자신만의 control flow를 가짐(각자 자신의 일 수행)   
> 각자 독립적인 코어에서 동작
> 각자 context switched가 발생

다른 점
> code와 data 공유
> 비용(cpu 시간, memory 차지) clock적으로 약 2배 이상 차이


## 이슈
1. fork와 exec (쓰레드가 fork를 부르면 어떻게 할 것인가)
> 모든 쓰레드를 다 복제할 것인가? 하나(fork를 부른)만 복제할 것인가?   
> pthread에서는 fork를 부른 쓰레드 하나만 복제
> exec(다른 프로세스로의 변경)를 부르면 전체 쓰레드를 다 죽이고 변경

2. 쓰레드 중간 정지(cancellation)
> 1. 비동기 캔슬(Asynchronous cancellation) 
> 쓰레드가 중요작업을 수행하고 있었을 경우 문제가 될 수 있음
> 2. Deferred(연기된) cancellation
> 자신이 종료되어야 하는 것을 알고 중요작업을 정리하고 그 후에 스스로 종료

3. signal이 발생하면 어떤 쓰레드에게 전달해야 하는가?
> 1. 모든 쓰레드에게 모두 전달
> 2. 특정한 쓰레드에게만 전달

4. 라이브러리 사용 문제
> 전역 변수의 의도치 않은 전파   
> 따라서 라이브러리를 사용하려면 reentrant, thread-safe한 라이브러리인지 잘 파악해야 함   

## 한계점
1. 프로레스에 비하여 가볍지만 여전히 많은 코스트 발생(쓰레드 오퍼레이션은 모두 시스템 콜)
2. 동시성 문제
3. 각 쓰레드별로 TCB 유지 (쓰레드의 개수도 제한이 있음 - linux 25만)

## user level thread
User level thread는 조금 더 가벼움(PC, registers, a stack, 유저 레벨 라이브러리 위에 TCB저장)   
유저레벨 쓰레드는 커널레벨 쓰레드보다 10배에서 100배 빠름   

유저레벨 쓰레드의 한계는 운영체제에게 보이지 않음 => 따라서 OS가 안 좋은 결정을 할 수 있음
> 대기 중인 쓰레드 임에도 CPU가 할당 될 수 있음   
> 중요한 작업 중인데 CPU를 선점   