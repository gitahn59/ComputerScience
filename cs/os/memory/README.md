# 메모리 관리
목적
1. 사용자에게 편리한 추상화를 제공(HW에 상관없이 SW 구현 가능)
2. 프로세스들 사이의 격리(protection)
3. 프로세스를 위한 메모리 할당

하나의 메모리 공간을 여러 개의 프로세스에게 제공하는 과정   
각 프로세스는 일반적으로 연속된 공간을 요구함
1. Protection : 프로세스가 써야 하는 영역을 제한해야함
2. Fast Translation : 가상 메모리 주소를 물리 주소로 빠르게 변환
3. Fast context switching : 빠른 컨택스트 스위칭 필요

## Fixed Partitions
각 프로세스마다 partition을 부여한다.
가상 주소는 프로세스마다 부여된 partition의 base 주소에 더하여 계산한다.
1. 파티션의 개수 = 동시에 실행가능한 프로세스의 개수(더 이상 파티션 할당 불가능)
2. 베이스 주소를 저장하는 레지스터

장점)   
구현이 쉽고, 빠르게 context switch 가능   
   
단점)    
내부 단편화 : 특정 파티션이 프로세스에 의해서 쓰이고 있으면 공간이 남아있음에도 다른 프로세스는 사용할 수 없음.
파티션의 크기 문제 : 파티션이 작으면 프로세스가 동작할 수없고, 크면 단편화 증가

개선된 방법
다양한 크기의 파티션을 준비한다.  
First fit : 그냥 빈 파티션을 찾으면 바로 할당(빈 파티션을 찾이 위해 스캐닝 필요)   
Best fit : 가장 적당한 파티션을 찾아 할당(더 많은 스캐닝 필요)   

## Variable Partitions
필요한 만큼만 메로리(파티션)를 할당하는 방법   
따라서 시작주소(Base)와 가능한 리밋(limit) 크기를 저장하는 레지스터가 필요함   

장점 
내부 단편화가 없음 => 빈 공간은 언제든지 사용할 수 있음   
단점
외부 단편화 : 전체 남은 공간을 합치면 충분한 크기이지만, 구간이 나누어져있어 프로세스를 할당할 수 없는 문제
해결책 : Compaction(압축) : overhead 발생
paging and segmentation으로 문제 해결

## Overlays
물리 메모리에는 그 때 그 떄 필요한 인스트런션과 데이터만 올려서 사용   
작은 메모리에서 동작할 수 있지만 사용자가 직접 구현해야 함

## Swapping
물리 메모리에 각 프로세스가 사용하는 내용을 넣었다 뺐다 스와핑 하는 방식
필요한 전체 데이터를 디스크에 내렸다가 메모리에 올렸다 반복 => 스와핑 시간이 오래걸림
현대의 프로세서는 스와핑 메카니즘을 수정(demand paging)하여 paging 단위로 사용

